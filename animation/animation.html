<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Oscillating Smooth Circle Controls</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #000000;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 16px;
      margin-bottom: 16px;
      background: #a151517a;
      color: aliceblue;
      padding: 16px 24px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 170px;
    }
    .control-group label {
      min-width: 60px;
      font-size: 0.95em;
    }
    canvas {
      display: block;
      background: rgb(29, 27, 27);
      box-shadow: 0 2px 16px rgba(0,0,0,0.1);
      margin: 0 auto;
    }
  </style>
</head>
<body>
<div id="controls">
  <div class="control-group">
    <label for="agitation">Agitation</label>
    <input type="range" id="agitation" min="0" max="1" step="0.01" value="0">
    <span id="agitation_val">0.00</span>
  </div>
</div>
<canvas id="wave"></canvas>
<script>
const canvas = document.getElementById('wave');
const ctx = canvas.getContext('2d');

// Controls
const agitationInput = document.getElementById('agitation');
const agitationVal = document.getElementById('agitation_val');

// Fixed values
const amplitude = 0.04;
const lineWeight = 3;

// State
let agitation = +agitationInput.value;
let numPoints = 16;
let speed = 1;
let lineColor = 'hsl(240, 80%, 50%)'; // initial blue

// Update agitation and derived parameters
agitationInput.addEventListener('input', () => {
  agitation = +agitationInput.value;
  agitationVal.textContent = agitation.toFixed(2);
  updateAgitationParams();
  resetPhases();
});
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpHue(a, b, t) {
  // Interpolate hue taking the shortest path around the color wheel
  let d = b - a;
  if (d > 180) d -= 360;
  if (d < -180) d += 360;
  return (a + d * t + 360) % 360;
}
function updateAgitationParams() {
  // Points: 16 to 100
  numPoints = Math.round(lerp(16, 100, agitation));
  // Speed: 1 to 20
  speed = lerp(1, 20, agitation);
  // Color: blue (240) -> purple (280) -> red (0)
  let hue;
  if (agitation < 0.5) {
    hue = lerpHue(240, 280, agitation * 2); // 0..0.5: blue to purple
  } else {
    hue = lerpHue(280, 0, (agitation - 0.5) * 2); // 0.5..1: purple to red
  }
  lineColor = `hsl(${hue}, 80%, 50%)`;
  agitationVal.textContent = agitation.toFixed(2);
}
updateAgitationParams();

// Responsive square canvas
function resizeCanvas() {
  const size = Math.min(window.innerWidth, window.innerHeight) * 0.92;
  canvas.width = size;
  canvas.height = size;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Animated point phases/amplitudes
let phases = [];
let amplitudesArr = [];
function resetPhases() {
  phases = [];
  amplitudesArr = [];
  for (let i = 0; i < numPoints; i++) {
    phases[i] = Math.random() * Math.PI * 2;
    amplitudesArr[i] = amplitude; // fixed amplitude
  }
}
resetPhases();

// Regenerate phases/amplitudes if numPoints changes
function maybeResetPhases(lastNumPoints) {
  if (lastNumPoints !== numPoints) {
    resetPhases();
  }
}

function getOscillatingPoints(cx, cy, baseRadius, t) {
  const pts = [];
  for (let i = 0; i < numPoints; i++) {
    const angle = (i / numPoints) * 2 * Math.PI;
    const osc = Math.sin(t * speed + phases[i]);
    const r = baseRadius * (1 + amplitudesArr[i] * osc);
    pts.push({
      x: cx + r * Math.cos(angle),
      y: cy + r * Math.sin(angle),
      angle: angle,
      r: r
    });
  }
  return pts;
}

// Helper: get control point for BÃ©zier curve, tangent to the circle at given point
function getControlPoint(pt, angle, handleLen) {
  // Tangent is perpendicular to radius
  const tangentAngle = angle + Math.PI/2;
  return {
    x: pt.x + Math.cos(tangentAngle) * handleLen,
    y: pt.y + Math.sin(tangentAngle) * handleLen
  };
}

let lastNumPoints = numPoints;
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // If numPoints changed, reset phases
  maybeResetPhases(lastNumPoints);
  lastNumPoints = numPoints;

  const w = canvas.width;
  const h = canvas.height;
  const cx = w / 2;
  const cy = h / 2;
  const baseRadius = w * 0.5 * 0.5; // 50% of width, then half for radius

  const t = performance.now() * 0.001;
  const points = getOscillatingPoints(cx, cy, baseRadius, t);

  // Dynamically compute optimal handle length for smoothness
  const kappa = 0.5522847498;
  const theta = 2 * Math.PI / numPoints;

  ctx.beginPath();
  for (let i = 0; i < numPoints; i++) {
    const curr = points[i];
    const next = points[(i + 1) % numPoints];

    // Average radius for handle length
    const avgR = (curr.r + next.r) / 2;
    const handleLen = avgR * kappa * theta; // optimal for circle with n points

    // Outgoing control point from curr (tangent to circle at curr)
    const cp1 = getControlPoint(curr, curr.angle, handleLen);
    // Incoming control point to next (tangent to circle at next, but reversed)
    const cp2 = getControlPoint(next, next.angle, -handleLen);

    if (i === 0) ctx.moveTo(curr.x, curr.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, next.x, next.y);
  }
  ctx.closePath();
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = lineWeight;
  ctx.stroke();

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
